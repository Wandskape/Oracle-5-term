-- 1.	Создайте таблицу, имеющую несколько атрибутов, один из которых первичный ключ.
CREATE TABLE BLOCK
( BLOCK_ID NUMBER NOT NULL PRIMARY KEY,
  BLOCK_NAME NVARCHAR2(50),
  BLOCK_TYPE NVARCHAR2(50)
);

-- 2.	Заполните таблицу строками (10 шт.).
INSERT INTO BLOCK VALUES(1, 'dirt', 'building');
INSERT INTO BLOCK VALUES(2, 'cobblestone', 'building');
INSERT INTO BLOCK VALUES(3, 'stone', 'building');
INSERT INTO BLOCK VALUES(4, 'brick', 'building');
INSERT INTO BLOCK VALUES(5, 'coal ore', 'mineral');
INSERT INTO BLOCK VALUES(6, 'iron ore', 'mineral');
INSERT INTO BLOCK VALUES(7, 'gold ore', 'mineral');
INSERT INTO BLOCK VALUES(8, 'copper ore', 'mineral');
INSERT INTO BLOCK VALUES(9, 'oak wood', 'wood related');
INSERT INTO BLOCK VALUES(10, 'oak planks', 'wood related');

SELECT * FROM BLOCK;
-- 3.	Создайте BEFORE – триггер уровня оператора на события INSERT, DELETE и UPDATE.
-- 4.	Этот и все последующие триггеры должны выдавать сообщение на серверную консоль (DMS_OUTPUT) со своим собственным именем. 
CREATE OR REPLACE TRIGGER BLOCK_INSERT_TRIGGER_BEFORE
BEFORE INSERT ON BLOCK
BEGIN DBMS_OUTPUT.PUT_LINE('BLOCK_INSERT_TRIGGER_BEFORE');
END;

INSERT INTO BLOCK VALUES(11, 'oak button', 'wood related');

CREATE OR REPLACE TRIGGER BLOCK_DELETE_TRIGGER_BEFORE
BEFORE DELETE ON BLOCK
BEGIN DBMS_OUTPUT.PUT_LINE('BLOCK_DELETE_TRIGGER_BEFORE');
END;

DELETE BLOCK WHERE BLOCK_ID = 11;

CREATE OR REPLACE TRIGGER BLOCK_UPDATE_TRIGGER_BEFORE
BEFORE UPDATE ON BLOCK
BEGIN DBMS_OUTPUT.PUT_LINE('BLOCK_UPDATE_TRIGGER_BEFORE');
END;

UPDATE BLOCK SET BLOCK_NAME = 'oak door' WHERE BLOCK_ID = 11;

-- 5.	Создайте BEFORE-триггер уровня строки на события INSERT, DELETE и UPDATE.
CREATE OR REPLACE TRIGGER BLOCK_INSERT_TRIGGER_ROW_BEFORE
BEFORE INSERT ON BLOCK 
FOR EACH ROW
BEGIN 
DBMS_OUTPUT.PUT_LINE('BLOCK_INSERT_TRIGGER_ROW_BEFORE');
END;

INSERT INTO BLOCK VALUES(11, 'oak button', 'wood related');

CREATE OR REPLACE TRIGGER BLOCK_UPDATE_TRIGGER_ROW_BEFORE
BEFORE UPDATE ON BLOCK 
FOR EACH ROW
BEGIN 
DBMS_OUTPUT.PUT_LINE('BLOCK_UPDATE_TRIGGER_ROW_BEFORE');
END;

UPDATE BLOCK SET BLOCK_NAME = 'oak door' WHERE BLOCK_ID = 11;

CREATE OR REPLACE TRIGGER BLOCK_DELETE_TRIGGER_ROW_BEFORE
BEFORE DELETE ON BLOCK 
FOR EACH ROW
BEGIN 
DBMS_OUTPUT.PUT_LINE('BLOCK_DELETE_TRIGGER_ROW_BEFORE');
END;

DELETE BLOCK WHERE BLOCK_ID = 11;

-- 6.	Примените предикаты INSERTING, UPDATING и DELETING.
CREATE OR REPLACE TRIGGER PREDICATE_TRIGGER_BLOCK_BEFORE
BEFORE INSERT OR UPDATE OR DELETE ON BLOCK
BEGIN 
    IF INSERTING THEN
    DBMS_OUTPUT.PUT_LINE('BLOCK_BEFORE_INSERT_TRIGGER');
    ELSIF UPDATING THEN
    DBMS_OUTPUT.PUT_LINE('BLOCK_BEFORE_UPDATE_TRIGGER');
    ELSIF DELETING THEN
    DBMS_OUTPUT.PUT_LINE('BLOCK_BEFORE_DELETE_TRIGGER');
    END IF;
END;

DROP TRIGGER BLOCK_INSERT_TRIGGER_BEFORE;
DROP TRIGGER BLOCK_DELETE_TRIGGER_BEFORE;
DROP TRIGGER BLOCK_UPDATE_TRIGGER_BEFORE;



CREATE OR REPLACE TRIGGER PREDICATE_TRIGGER_BLOCK_BEFORE_ROW
BEFORE INSERT OR UPDATE OR DELETE ON BLOCK
FOR EACH ROW
BEGIN 
    IF INSERTING THEN
    DBMS_OUTPUT.PUT_LINE('BLOCK_BEFORE_INSERT_TRIGGER_ROW');
    ELSIF UPDATING THEN
    DBMS_OUTPUT.PUT_LINE('BLOCK_BEFORE_UPDATE_TRIGGER_ROW');
    ELSIF DELETING THEN
    DBMS_OUTPUT.PUT_LINE('BLOCK_BEFORE_DELETE_TRIGGER_ROW');
    END IF;
END; 

DROP TRIGGER BLOCK_INSERT_TRIGGER_ROW_BEFORE;
DROP TRIGGER BLOCK_DELETE_TRIGGER_ROW_BEFORE;
DROP TRIGGER BLOCK_UPDATE_TRIGGER_ROW_BEFORE;

-- 7.	Разработайте AFTER-триггеры уровня оператора на события INSERT, DELETE и UPDATE.
CREATE OR REPLACE TRIGGER BLOCK_INSERT_TRIGGER
AFTER INSERT ON BLOCK
BEGIN DBMS_OUTPUT.PUT_LINE('BLOCK_INSERT_TRIGGER');
END;

INSERT INTO BLOCK VALUES(11, 'oak button', 'wood related');

CREATE OR REPLACE TRIGGER BLOCK_DELETE_TRIGGER
AFTER DELETE ON BLOCK
BEGIN DBMS_OUTPUT.PUT_LINE('BLOCK_DELETE_TRIGGER');
END;

DELETE BLOCK WHERE BLOCK_ID = 11;

CREATE OR REPLACE TRIGGER BLOCK_UPDATE_TRIGGER
AFTER UPDATE ON BLOCK
BEGIN DBMS_OUTPUT.PUT_LINE('BLOCK_UPDATE_TRIGGER');
END;

UPDATE BLOCK SET BLOCK_NAME = 'oak door' WHERE BLOCK_ID = 11;
-- 8.	Разработайте AFTER-триггеры уровня строки на события INSERT, DELETE и UPDATE.
CREATE OR REPLACE TRIGGER BLOCK_INSERT_TRIGGER_ROW
AFTER INSERT ON BLOCK 
FOR EACH ROW
BEGIN 
DBMS_OUTPUT.PUT_LINE('BLOCK_INSERT_TRIGGER_ROW');
END;

INSERT INTO BLOCK VALUES(11, 'oak button', 'wood related');

CREATE OR REPLACE TRIGGER BLOCK_UPDATE_TRIGGER_ROW
AFTER UPDATE ON BLOCK 
FOR EACH ROW
BEGIN 
DBMS_OUTPUT.PUT_LINE('BLOCK_UPDATE_TRIGGER_ROW');
END;

UPDATE BLOCK SET BLOCK_NAME = 'oak door' WHERE BLOCK_ID = 11;

CREATE OR REPLACE TRIGGER BLOCK_DELETE_TRIGGER_ROW
AFTER DELETE ON BLOCK 
FOR EACH ROW
BEGIN 
DBMS_OUTPUT.PUT_LINE('BLOCK_DELETE_TRIGGER_ROW');
END;

DELETE BLOCK WHERE BLOCK_ID = 11;

----------
CREATE OR REPLACE TRIGGER PREDICATE_TRIGGER_BLOCK_AFTER
AFTER INSERT OR UPDATE OR DELETE ON BLOCK
BEGIN 
    IF INSERTING THEN
    DBMS_OUTPUT.PUT_LINE('BLOCK_AFTER_INSERT_TRIGGER');
    ELSIF UPDATING THEN
    DBMS_OUTPUT.PUT_LINE('BLOCK_AFTER_UPDATE_TRIGGER');
    ELSIF DELETING THEN
    DBMS_OUTPUT.PUT_LINE('BLOCK_AFTER_DELETE_TRIGGER');
    END IF;
END;

DROP TRIGGER BLOCK_INSERT_TRIGGER;
DROP TRIGGER BLOCK_DELETE_TRIGGER;
DROP TRIGGER BLOCK_UPDATE_TRIGGER;

CREATE OR REPLACE TRIGGER PREDICATE_TRIGGER_BLOCK_AFTER_ROW
AFTER INSERT OR UPDATE OR DELETE ON BLOCK
FOR EACH ROW
BEGIN 
    IF INSERTING THEN
    DBMS_OUTPUT.PUT_LINE('BLOCK_AFTER_INSERT_TRIGGER_ROW');
    ELSIF UPDATING THEN
    DBMS_OUTPUT.PUT_LINE('BLOCK_AFTER_UPDATE_TRIGGER_ROW');
    ELSIF DELETING THEN
    DBMS_OUTPUT.PUT_LINE('BLOCK_AFTER_DELETE_TRIGGER_ROW');
    END IF;
END; 

DROP TRIGGER BLOCK_INSERT_TRIGGER_ROW;
DROP TRIGGER BLOCK_DELETE_TRIGGER_ROW;
DROP TRIGGER BLOCK_UPDATE_TRIGGER_ROW;
-- 9.	Создайте таблицу с именем AUDIT. Таблица должна содержать поля: OperationDate, 
                                                                        -- OperationType (операция вставки, обновления и удаления),
                                                                        -- TriggerName(имя триггера),
                                                                        -- Data (строка с значениями полей до и после операции).
CREATE TABLE AUDIT_INVALID_NAME (
    OperationDate TIMESTAMP DEFAULT SYSTIMESTAMP,
    OperationType VARCHAR2(20), -- Вставка, обновление, удаление
    TriggerName VARCHAR2(50), -- Имя триггера
    Data CLOB -- Данные до/после операции
);

-- 10.	Измените триггеры таким образом, чтобы они регистрировали все операции с исходной таблицей в таблице AUDIT.
CREATE OR REPLACE TRIGGER BLOCK_INSERT_TRIGGER_ROW_BEFORE
BEFORE INSERT ON BLOCK
FOR EACH ROW
BEGIN
    INSERT INTO AUDIT_INVALID_NAME (OperationType, TriggerName, Data)
    VALUES ('INSERT', 'BLOCK_INSERT_TRIGGER_ROW_BEFORE', 'New Data: ' || :NEW.BLOCK_ID || ', ' || :NEW.BLOCK_NAME || ', ' || :NEW.BLOCK_TYPE);
    DBMS_OUTPUT.PUT_LINE('BLOCK_INSERT_TRIGGER_ROW_BEFORE');
END;

CREATE OR REPLACE TRIGGER BLOCK_DELETE_TRIGGER_ROW_BEFORE
BEFORE DELETE ON BLOCK
FOR EACH ROW
BEGIN
    INSERT INTO AUDIT_INVALID_NAME (OperationType, TriggerName, Data)
    VALUES ('DELETE', 'BLOCK_DELETE_TRIGGER_ROW_BEFORE', 'Old Data: ' || :OLD.BLOCK_ID || ', ' || :OLD.BLOCK_NAME || ', ' || :OLD.BLOCK_TYPE);
    DBMS_OUTPUT.PUT_LINE('BLOCK_DELETE_TRIGGER_ROW_BEFORE');
END;

CREATE OR REPLACE TRIGGER BLOCK_UPDATE_TRIGGER_ROW_BEFORE
BEFORE UPDATE ON BLOCK
FOR EACH ROW
BEGIN
    INSERT INTO AUDIT_INVALID_NAME (OperationType, TriggerName, Data)
    VALUES ('UPDATE', 'BLOCK_UPDATE_TRIGGER_ROW_BEFORE', 
            'Old Data: ' || :OLD.BLOCK_ID || ', ' || :OLD.BLOCK_NAME || ', ' || :OLD.BLOCK_TYPE || 
            '; New Data: ' || :NEW.BLOCK_ID || ', ' || :NEW.BLOCK_NAME || ', ' || :NEW.BLOCK_TYPE);
    DBMS_OUTPUT.PUT_LINE('BLOCK_UPDATE_TRIGGER_ROW_BEFORE');
END;

-------------------
CREATE OR REPLACE TRIGGER BLOCK_INSERT_TRIGGER_ROW_AFTER
AFTER INSERT ON BLOCK
FOR EACH ROW
BEGIN
    INSERT INTO AUDIT_INVALID_NAME (OperationType, TriggerName, Data)
    VALUES ('INSERT', 'BLOCK_INSERT_TRIGGER_ROW_AFTER', 'New Data: ' || :NEW.BLOCK_ID || ', ' || :NEW.BLOCK_NAME || ', ' || :NEW.BLOCK_TYPE);
    DBMS_OUTPUT.PUT_LINE('BLOCK_INSERT_TRIGGER_ROW_AFTER');
END;

CREATE OR REPLACE TRIGGER BLOCK_DELETE_TRIGGER_ROW_AFTER
AFTER DELETE ON BLOCK
FOR EACH ROW
BEGIN
    INSERT INTO AUDIT_INVALID_NAME (OperationType, TriggerName, Data)
    VALUES ('DELETE', 'BLOCK_DELETE_TRIGGER_ROW_AFTER', 'Old Data: ' || :OLD.BLOCK_ID || ', ' || :OLD.BLOCK_NAME || ', ' || :OLD.BLOCK_TYPE);
    DBMS_OUTPUT.PUT_LINE('BLOCK_DELETE_TRIGGER_ROW_AFTER');
END;

CREATE OR REPLACE TRIGGER BLOCK_UPDATE_TRIGGER_ROW_AFTER
AFTER UPDATE ON BLOCK
FOR EACH ROW
BEGIN
    INSERT INTO AUDIT_INVALID_NAME (OperationType, TriggerName, Data)
    VALUES ('UPDATE', 'BLOCK_UPDATE_TRIGGER_ROW_AFTER', 
            'Old Data: ' || :OLD.BLOCK_ID || ', ' || :OLD.BLOCK_NAME || ', ' || :OLD.BLOCK_TYPE || 
            '; New Data: ' || :NEW.BLOCK_ID || ', ' || :NEW.BLOCK_NAME || ', ' || :NEW.BLOCK_TYPE);
    DBMS_OUTPUT.PUT_LINE('BLOCK_UPDATE_TRIGGER_ROW_AFTER');
END;


-- 11.	Выполните операцию, нарушающую целостность таблицы по первичному ключу. Выясните, зарегистрировал ли триггер это событие. Объясните результат.
INSERT INTO BLOCK VALUES(16, 'duplicate', 'wood related');

DROP TRIGGER BLOCK_INSERT_TRIGGER_BEFORE;

-- 12.	Удалите (drop) исходную таблицу. Объясните результат. Добавьте триггер, запрещающий удаление исходной таблицы.
DROP TABLE BLOCK;

CREATE OR REPLACE TRIGGER PREVENT_BLOCK_DROP
BEFORE DROP ON SCHEMA
BEGIN
    IF DICTIONARY_OBJ_NAME = 'BLOCK' THEN
        RAISE_APPLICATION_ERROR(-20001, 'Удаление таблицы BLOCK запрещено.');
        DBMS_OUTPUT.PUT_LINE('PREVENT_BLOCK_DROP');
    END IF;
END;

-- 13.	Удалите (drop) таблицу AUDIT. Просмотрите состояние триггеров с помощью SQL-DEVELOPER. Объясните результат. Измените триггеры.
DROP TABLE AUDIT_INVALID_NAME;

-- 14.	Создайте представление над исходной таблицей. Разработайте INSTEADOF INSERT-триггер. Триггер должен добавлять строку в таблицу.
CREATE VIEW BLOCK_VIEW AS
SELECT BLOCK_ID, BLOCK_NAME FROM BLOCK;

CREATE OR REPLACE TRIGGER BLOCK_VIEW_INSERT
INSTEAD OF INSERT ON BLOCK_VIEW
BEGIN
    INSERT INTO BLOCK (BLOCK_ID, BLOCK_NAME, BLOCK_TYPE)
    VALUES (:NEW.BLOCK_ID, :NEW.BLOCK_NAME, 'default type');
    DBMS_OUTPUT.PUT_LINE('INSTEAD OF INSERT TRIGGER');
END;

SELECT * FROM BLOCK_VIEW;
SELECT * FROM BLOCK;
INSERT INTO BLOCK_VIEW VALUES(18, 'BERRY');

-- 15.	Продемонстрируйте, в каком порядке выполняются триггеры.
CREATE OR REPLACE TRIGGER BEFORE_INSERT_BLOCK_15
BEFORE INSERT ON BLOCK
BEGIN
    DBMS_OUTPUT.PUT_LINE('BEFORE INSERT TRIGGER 15');
END;

CREATE OR REPLACE TRIGGER AFTER_INSERT_BLOCK_15
AFTER INSERT ON BLOCK
BEGIN
    DBMS_OUTPUT.PUT_LINE('AFTER INSERT TRIGGER 15');
END;

CREATE OR REPLACE TRIGGER BEFORE_INSERT_BLOCK_ROW_15
BEFORE INSERT ON BLOCK
FOR EACH ROW
BEGIN
    DBMS_OUTPUT.PUT_LINE('BEFORE INSERT ROW TRIGGER 15');
END;

CREATE OR REPLACE TRIGGER AFTER_INSERT_BLOCK_ROW_15
AFTER INSERT ON BLOCK
FOR EACH ROW
BEGIN
    DBMS_OUTPUT.PUT_LINE('AFTER INSERT ROW TRIGGER 15');
END;

INSERT INTO BLOCK VALUES(13, 'diamond ore', 'mineral');

DROP TRIGGER BEFORE_INSERT_BLOCK;

------
SELECT TRIGGER_NAME, TABLE_NAME, STATUS 
FROM USER_TRIGGERS;

SELECT 'DROP TRIGGER ' || TRIGGER_NAME || ';' AS DROP_COMMAND
FROM USER_TRIGGERS
WHERE TABLE_NAME = 'BLOCK';

DROP TRIGGER BLOCK_UPDATE_TRIGGER_ROW_AFTER;
DROP TRIGGER BLOCK_VIEW_INSERT;
DROP TRIGGER PREVENT_BLOCK_DROP;
DROP TRIGGER BLOCK_UPDATE_TRIGGER;
DROP TRIGGER BLOCK_INSERT_TRIGGER;
DROP TRIGGER BLOCK_DELETE_TRIGGER;
DROP TRIGGER BLOCK_INSERT_TRIGGER_ROW;
DROP TRIGGER BLOCK_UPDATE_TRIGGER_ROW;
DROP TRIGGER BLOCK_DELETE_TRIGGER_ROW;
DROP TRIGGER BLOCK_DELETE_TRIGGER_BEFORE;
DROP TRIGGER BLOCK_UPDATE_TRIGGER_BEFORE;
DROP TRIGGER PREDICATE_TRIGGER_BLOCK_BEFORE;
DROP TRIGGER PREDICATE_TRIGGER_BLOCK_BEFORE_ROW;
DROP TRIGGER PREDICATE_TRIGGER_BLOCK_AFTER;
DROP TRIGGER PREDICATE_TRIGGER_BLOCK_AFTER_ROW;
DROP TRIGGER BEFORE_INSERT_BLOCK_ROW_15;
DROP TRIGGER BLOCK_INSERT_TRIGGER_ROW_BEFORE;
DROP TRIGGER BLOCK_DELETE_TRIGGER_ROW_BEFORE;
DROP TRIGGER AFTER_INSERT_BLOCK_ROW_15;
DROP TRIGGER BEFORE_INSERT_BLOCK_15;
DROP TRIGGER AFTER_INSERT_BLOCK_15;
DROP TRIGGER BLOCK_INSERT_TRIGGER_ROW_AFTER;
DROP TRIGGER BLOCK_UPDATE_TRIGGER_ROW_BEFORE;
DROP TRIGGER BLOCK_DELETE_TRIGGER_ROW_AFTER;

DROP TABLE BLOCK;
DROP TABLE AUDIT_INVALID_NAME;
